
### Expanded Use Case 8: Perform Noise Handshake
| | |
|---|---|
| **Use Case ID** | UC-08 |
| **Use Case Name** | Perform Noise Handshake |
| **Actor** | System (Primary) |
| **Description** | Establishes a secure end-to-end encrypted session between two devices using the Noise Protocol Framework (specifically, the `XX` or `KK` pattern). This is a prerequisite for all secure communication. |
| **Trigger** | • System needs to send a message to a contact with no existing secure session. <br> • A nearby device initiates a handshake with the current user's device. <br> • User manually requests to re-establish a secure connection. |
| **Precondition** | • Both devices have the app installed and running. <br> • BLE is enabled on both devices. <br> • Devices are within BLE range (discoverable and connectable). <br> • Both devices have generated their long-term identity keys (for `KK` pattern). |
| **Post Condition** | **Success:** A symmetric encryption key is derived on both devices, and a secure session is established. The contact's security level is updated to `high`. <br> **Failure:** Handshake fails, no session is created. An error is logged, and the system may schedule a retry. |
| **Normal Flow** | 1. **Initiator:** The `HandshakeCoordinator` decides to start a handshake (e.g., before sending a message). <br> 2. **Initiator:** Selects the appropriate Noise pattern (`KK` if keys are pre-shared, `XX` otherwise). <br> 3. **Initiator:** Sends the first handshake message (e.g., `-> e` for `XX`). <br> 4. **Responder:** Receives the first message via `BleMessageHandler`. <br> 5. **Responder:** Processes the message using its own Noise state machine. <br> 6. **Responder:** Sends the second handshake message (e.g., `<- e, ee, s, es`). <br> 7. **Initiator:** Receives and processes the second message, deriving the shared secret. <br> 8. **Initiator:** Sends the final handshake message (e.g., `-> s, se`). <br> 9. **Responder:** Receives and processes the final message, deriving the same shared secret. <br> 10. **Both:** Two `CipherState` objects are created for bidirectional encryption. <br> 11. **Both:** The `NoiseSession` is stored in memory and the contact's status is updated in the database. |
| **Alternative Flow** | **7a. Handshake Role Conflict:** <br>   7a.1. If both devices initiate a handshake simultaneously, a deterministic role resolution mechanism (e.g., based on public key comparison) decides who continues as Initiator. <br>   7a.2. The other device transitions to the Responder role. <br><br> **2a. `KK` Pattern Handshake:** <br>   2a.1. System verifies it has the contact's public static key. <br>   2a.2. Handshake proceeds following the `KK` pattern message flow (`-> e`, `<- e, es, ss`). |
| **Exceptional Flow** | **E1. Handshake Message Timeout:** <br>   - If a response is not received within a specific timeout (e.g., 5 seconds), the `HandshakeCoordinator` aborts the process. <br>   - An error is logged, and a retry is scheduled with exponential backoff. <br><br> **E2. Invalid Handshake Message:** <br>   - If a device receives a malformed or unexpected handshake message, it immediately discards the message and terminates the handshake. <br>   - The `NoiseHandshakeException` is thrown and logged. <br><br> **E3. Cryptographic Verification Failure:** <br>   - If a cryptographic check (e.g., MAC verification) fails at any step, the handshake is aborted to prevent security breaches. <br>   - The session state is cleared, and a severe error is logged. |
| **Special Requirements** | • **Security:** Must strictly adhere to the chosen Noise Protocol pattern. No custom modifications. <br> • **Performance:** The entire handshake process should complete in under 2 seconds under normal conditions. <br> • **State Management:** The handshake state machine must be managed carefully to prevent state corruption or reuse of ephemeral keys. |
| **Frequency of Use** | Medium - Occurs once per new contact interaction and periodically to re-establish sessions. |
| **Assumptions** | • The underlying BLE connection is stable during the handshake process. <br> • Device clocks are reasonably synchronized, although Noise is robust against some clock drift. |

### Expanded Use Case 23: Send Group Message
| | |
|---|---|
| **Use Case ID** | UC-23 |
| **Use Case Name** | Send Group Message |
| **Actor** | User (Primary) |
| **Description** | User sends a message to a pre-defined group. The system encrypts and sends the message individually to each group member (multi-unicast). |
| **Trigger** | User taps the 'Send' button in a group chat screen. |
| **Precondition** | • User is part of the group. <br> • The group and its members are defined in the `ContactGroup` repository. <br> • The user has established Noise sessions with all online group members. |
| **Post Condition** | **Success:** The message is saved to the local database. It is individually encrypted and sent (or queued) to each group member. UI shows the message with a 'Sending' status. <br> **Failure:** Message sending fails for all members. The message remains in a draft or failed state in the UI. |
| **Normal Flow** | 1. User types a message in the group chat view and taps 'Send'. <br> 2. The `GroupMessagingService` is invoked. <br> 3. The system creates a single `GroupMessage` object with a unique ID. <br> 4. The system retrieves the list of all members in the group from `GroupRepository`. <br> 5. The system iterates through each member of the group. <br> 6. For each member, the system retrieves their individual `NoiseSession`. <br> 7. The message content is encrypted separately for each member using their respective session keys. <br> 8. Each encrypted message is sent to the corresponding member as a standard one-to-one message. <br> 9. The `GroupMessage` is saved in the `group_messages` table. <br> 10. A delivery status record is created for each member in the `group_message_delivery` table, initially marked as 'Sending'. <br> 11. The UI updates to show the sent message. |
| **Alternative Flow** | **6a. Member is Offline or No Session Exists:** <br>   6a.1. If a member is not connected or no `NoiseSession` is available, the system queues the encrypted message for that specific member in the `offline_message_queue`. <br>   6a.2. The delivery status for that member is marked as 'Queued'. <br>   6a.3. The system proceeds to send messages to the other online members. <br><br> **8a. Sending via Mesh Relay:** <br>   8a.1. If a group member is not directly reachable but is part of the mesh network, the system wraps the encrypted message in a `MeshRelayMessage`. <br>   8a.2. The `MeshRelayEngine` determines the next hop and forwards the message. |
| **Exceptional Flow** | **E1. Partial Send Failure:** <br>   - If sending fails for a subset of members (e.g., due to BLE disconnection), their delivery status is updated to 'Failed'. <br>   - The system will attempt to retry sending to the failed members based on the standard message retry logic. <br>   - The message is considered successfully sent from the user's perspective, but delivery status will vary per member. <br><br> **E2. Database Failure:** <br>   - If the system fails to write the `GroupMessage` or delivery status records to the database, the entire operation is rolled back. <br>   - An error is displayed to the user, and the message remains in the input field. |
| **Special Requirements** | • **Scalability:** The system must handle groups of up to 50 members without significant UI lag. <br> • **Data Integrity:** Delivery status must be tracked accurately on a per-member basis. <br> • **Efficiency:** Avoid re-encrypting the same message for multiple users if possible, though multi-unicast requires it for security. |
| **Frequency of Use** | Medium to High, depending on the user's social interactions. |
| **Assumptions** | • The group membership list is up-to-date on the sender's device. <br> • The overhead of sending multiple individual messages is acceptable for the given group size and network conditions. |

### Expanded Use Case 31: Process Incoming Relay Message
| | |
|---|---|
| **Use Case ID** | UC-31 |
| **Use Case Name** | Process Incoming Relay Message |
| **Actor** | System (Primary) |
| **Description** | The system receives a message intended for another node in the mesh network. It processes the message and either forwards it to the next hop or, if it's the final destination, decrypts and displays it. |
| **Trigger** | The `BleMessageHandler` receives a `ProtocolMessage` of type `MESH_RELAY`. |
| **Precondition** | • The device is part of the mesh network and has relaying enabled. <br> • The device has an active BLE connection with the node that sent the message. |
| **Post Condition** | **Success (Forwarded):** The message is successfully passed to the `BleConnectionManager` to be sent to the next hop. <br> **Success (Delivered):** The message is decrypted, and a notification is shown to the user. <br> **Failure:** The message is dropped due to an error (e.g., invalid format, spam), and the event is logged. |
| **Normal Flow** | 1. `BleMessageHandler` receives a BLE packet and decodes it into a `ProtocolMessage`. <br> 2. The message type is identified as `MESH_RELAY`. <br> 3. The message is passed to the `MeshRelayEngine`. <br> 4. The engine parses the `MeshRelayMessage` wrapper, extracting metadata like `finalDestinationNodeId`, `hops`, and `route`. <br> 5. The engine checks if the `finalDestinationNodeId` matches the current device's ID. <br> 6. **If current device is the destination:** <br>   6a. The inner encrypted payload is extracted. <br>   6b. The system finds the correct `NoiseSession` based on the original sender's ID. <br>   6c. The payload is decrypted. <br>   6d. The decrypted message is passed to the `ChatService` to be saved and displayed. <br> 7. **If current device is a relay:** <br>   7a. The engine consults its routing table (or uses the route provided in the message) to determine the `nextHopNodeId`. <br>   7b. The `hops` count is incremented. <br>   7c. The message is placed in the outgoing `relayMessageQueue`. <br>   7d. The `BleConnectionManager` picks up the message and sends it to the next hop peer. |
| **Alternative Flow** | **4a. Spam/Filter Check:** <br>   4a.1. Before processing, the `SpamPreventionManager` inspects the message. <br>   4a.2. If the message is from a blocked user, has an invalid hop count, or matches a spam signature, it is dropped. The flow terminates here. <br><br> **7a.1. No Route to Destination:** <br>   7a.1.1. If the `MeshRelayEngine` cannot determine a next hop for the final destination, it may initiate a route discovery process. <br>   7a.1.2. If no route can be found, the message is dropped, and an error may be propagated back to the original sender if the protocol supports it. |
| **Exceptional Flow** | **E1. Decryption Failure:** <br>   - If the device is the final destination but fails to decrypt the payload (e.g., due to a missing or mismatched `NoiseSession`), the message is moved to a failed/quarantined state. <br>   - A log is generated, and the message is not displayed to the user. <br><br> **E2. Relay Queue Full:** <br>   - If the outgoing `relayMessageQueue` is full (to manage bandwidth and resources), the message may be temporarily dropped. <br>   - The system might employ strategies like prioritizing messages or notifying the network of congestion. <br><br> **E3. Invalid Relay Format:** <br>   - If the `MeshRelayMessage` is malformed or missing critical fields, it is discarded immediately to prevent network instability. |
| **Special Requirements** | • **Low Latency:** Processing and forwarding a relay message should take less than 100ms to keep the mesh network responsive. <br> • **Resource Management:** The relay queue size and processing rate must be carefully managed to avoid consuming excessive battery or memory. <br> • **Security:** The relay node must not be able to decrypt the inner message payload. All forwarding is done on the encrypted wrapper. |
| **Frequency of Use** | High - In a mesh network, a device may process many relay messages per minute. |
| **Assumptions** | • Nodes in the mesh network are cooperative and follow the protocol. <br> • The routing information is reasonably current. |
